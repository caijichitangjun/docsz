(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{572:function(e,t,v){e.exports=v.p+"assets/img/lifeCycle2.6f2c97f0.png"},573:function(e,t,v){e.exports=v.p+"assets/img/lifecycle3.d2f8a1b7.svg"},648:function(e,t,v){"use strict";v.r(t);var r=v(5),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),r("p",[r("strong",[e._v("什么是生命周期？")]),r("br"),e._v("\n       以我们自己举例，受精卵形成的那一刻是我们生命的开始，身体最后一个器官停止运动后是我们生命的结束，这就可以视为一个生命周期。"),r("br"),e._v("\n       在vue中，我们new一个Vue的实例时就代表vue的生命开始了，我们关闭页面时就代表vue的生命结束了。"),r("br"),e._v("\n       当然在vue项目中，我们使用的往往不是直白的vue实例对象，我们使用的是一个组件，那么组件的生命在它被调用时开始，在切换为下一个组件时终止。"),r("br"),e._v("\n       当然在生命周期中，我们很多时候往往在意的不是新生和终结这两个时间节点，我们在意的是，它一生干了什么？在vue项目中我们关注的有8个时刻，被称为生命周期钩子，代表着整个周期内的关键节点的所作所为。")]),e._v(" "),r("h3",{attrs:{id:"_8大生命周期钩子-vue2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8大生命周期钩子-vue2"}},[e._v("#")]),e._v(" 8大生命周期钩子（vue2）")]),e._v(" "),r("blockquote",[r("ol",[r("li",[e._v("beforeCreate:Vue实例创建前"),r("br"),e._v("\n       这时Vue实例还没创建呢！自然无法通过VM访问到data中数据、methods中方法")]),e._v(" "),r("li",[e._v("created:Vue实例创建后"),r("br"),e._v("\n       这时Vue实例已经创建，可以通过VM访问到data中数据、methods中方法")]),e._v(" "),r("li",[e._v("beforeMount:dom挂载到页面前"),r("br"),e._v("\n       页面呈现的是未经Vue编译的DOM结构。而且此时所有对DOM的操作，最终都不奏效。")]),e._v(" "),r("li",[e._v("mounted:dom挂载到页面后"),r("br"),e._v("\n       页面呈现的是已经经Vue编译的DOM结构。此时可以操作dom，如开启定时器、发送网络请求等")]),e._v(" "),r("li",[e._v("beforeUpdate:页面更新前"),r("br"),e._v("\n       此时页面还未更新，因此页面上展示的内容还是未更改的数据。")]),e._v(" "),r("li",[e._v("updated:页面更新后"),r("br"),e._v("\n       此时页面已经更新，因此页面上展示的内容还是更改的数据。")]),e._v(" "),r("li",[e._v("beforeDestroy:销毁前"),r("br"),e._v("\n       这是所有的内容都是可用的，一般用于关闭定时器，解绑自定义事件等。一般不推荐此时操作元素，因为其就要被销毁了，还折腾它干嘛！")]),e._v(" "),r("li",[e._v("destroyed:销毁后"),r("br"),e._v("\n       人都牺牲了，就别折腾它了！")])])]),e._v(" "),r("p",[r("img",{attrs:{src:v(572),alt:"生命周期演示图"}})]),e._v(" "),r("h3",{attrs:{id:"两个新的生命周期钩子及vue3的变化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两个新的生命周期钩子及vue3的变化"}},[e._v("#")]),e._v(" 两个新的生命周期钩子及vue3的变化")]),e._v(" "),r("p",[e._v("       为什么要引入这两个生命周期钩子？"),r("br"),e._v("\n       在我们引入"),r("RouterLink",{attrs:{to:"/demo/assembly/tryRouter.html"}},[e._v("route路由")]),e._v("时，页面通过路由跳转时，beforeDestroy有时会有点小问题。因为当设置了缓存路由组件时，跳转界面，更换显示内容，原内容仍然被保存着并没有被销毁，所以原先写在beforeDestroy的内容并不会被执行，因此需要用到新的生命周期钩子。")],1),e._v(" "),r("blockquote",[r("ol",[r("li",[e._v("activated:路由组件激活时"),r("br"),e._v("\n       通过路由跳转进入该路由界面时，此时原本写在mounted的打开定时器等操作就可以写在activated中实现。")]),e._v(" "),r("li",[e._v("deactivated:路由组件失活时"),r("br"),e._v("\n       通过路由跳转离开该路由界面时，此时原本写在beforeDestroy的内容都可以写在activated中实现。")]),e._v(" "),r("li",[e._v("beforeDestroy:销毁前  ===> beforeUnmount:卸载前")]),e._v(" "),r("li",[e._v("destroyed:销毁后  ===> unmounted:卸载后")])])]),e._v(" "),r("p",[r("img",{attrs:{src:v(573),alt:"生命周期演示图vue3"}})]),e._v(" "),r("p",[e._v("       因为在vue3中引入了组合式Api的概念，因此生命周期钩子也可以写在setup函数内部。不过需要更名：")]),e._v(" "),r("ul",[r("li",[e._v("beforeCreate    ====>   setup()")]),e._v(" "),r("li",[e._v("created         ====>   setup()")]),e._v(" "),r("li",[e._v("beforeMount     ====>   onBeforeMount()")]),e._v(" "),r("li",[e._v("mounted         ====>   onMounted()")]),e._v(" "),r("li",[e._v("beforeUpdate    ====>   onBeforeUpdate()")]),e._v(" "),r("li",[e._v("updated         ====>   onUpdated()")]),e._v(" "),r("li",[e._v("beforeUnmount   ====>   onBeforeUnmount()")]),e._v(" "),r("li",[e._v("unmounted       ====>   onUnmounted()")])])])}),[],!1,null,null,null);t.default=o.exports}}]);